---
title: "Using AWK and R to parse 25tb"
author: Nick Strayer
date: '2019-06-04'
slug: using_awk_and_R_to_parse_25tb
categories: ["big data", "awk", "data cleaning"]
tags:  ["big data", "awk", "data cleaning"]
excerpt: "Recently I was tasked with parsing 25tb of raw genotype data. This is the story of how I brought the query time and cost down from 8 minutes and $20 to a tenth of a second and less than a penny, plus the lessons learned along the way."
---



<style>
.lesson_learned {
  color: #238443;
}

.lesson_learned strong {
  color: #005a32;
}

.photo_caption {
  font-size: 0.8em;
}
</style>
<p><strong>How to read this post:</strong> I sincerely apologize for how long and rambling the following text is. To speed up skimming of it for those who have better things to do with their time, I have started most sections with a <span class="lesson_learned">“Lesson learned”</span> blurb that boils down the takeaway from the following text into a sentence or two.</p>
<p><strong>Just show me the solution!</strong> If you just want to see how I ended up solving the task jump to the section <a href='#getting-more-creative'>Getting More Creative</a>, but I honestly think the failures are more interesting/valuable.</p>
<div id="intro" class="section level2">
<h2>Intro</h2>
<p>Recently I was put in charge of setting up a workflow for dealing with a large amount of raw DNA sequencing (well technically a SNP chip) data for my lab. The goal was to be able to quickly get data for a given genetic location (called a SNP) for use for modeling etc. Using vanilla R and AWK I was able to cleanup and organize the data in a natural way, massively speeding up the querying. It certainly wasn’t easy and it took lots of iterations. This post is meant to help others avoid some of the same mistakes and show what did eventually work.</p>
<p>First some background:</p>
</div>
<div id="the-data" class="section level2">
<h2>The Data</h2>
<p>The data was delivered to us by our university’s genetics processing center as 25 TB of tsvs. Before handing it off to me, my advisor split and gzipped these files into five batches each composed of roughly 240 four gigabyte files. Each row contained a data for a single SNP for a single person. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">There were ~2.5 million SNPS and ~60 thousand people</span> Along with the SNP value there were multiple numeric columns on things like intensity of the reading, frequency of different alleles etc. All told there were around 30 columns with frustratingly unique values.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote"><img src='https://www.researchgate.net/profile/Debi_Mishra4/publication/320298591/figure/fig5/AS:547880880820228@1507636389471/DNA-chips-to-analyze-single-nucleotide-polymorphisms-SNPs-A-DNA-chip-is-repaired-by.png' alt='DNA chips explainer' width=200px/> How a SNP Chip works. <a href='https://www.researchgate.net/figure/DNA-chips-to-analyze-single-nucleotide-polymorphisms-SNPs-A-DNA-chip-is-repaired-by_fig5_320298591'>Via Research Gate</a></span></p>
</div>
<div id="the-goal" class="section level2">
<h2>The Goal</h2>
<p>As with any data management project the most important thing is to consider <em>how</em> the data will be used. In this case what <strong>we will mostly be doing is fitting models and workflows on a SNP by SNP basis.</strong> I.e. we only will need a single SNP’s data at a time. I needed to make it as easy, fast, and cheap as possible to extract all the records pertaining to one of the 2.5 million SNPs.</p>
</div>
<div id="how-not-to-do-this" class="section level1">
<h1>How <em>not</em> to do this</h1>
<p>To appropriate a cliched quote:</p>
<blockquote>
<p>I didn’t fail a thousand times, I just discovered a thousand ways <em>not</em> to parse lots of data into an easily query-able format.</p>
</blockquote>
<div id="the-first-attempt" class="section level2">
<h2>The first attempt</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> There’s no cheap way to parse 25tb of data at once.</span></p>
<p>Having taken a class at Vanderbilt titled ‘Advanced methods in Big Data’ I was sure I had this in the bag. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">Capital B capital D Big Data, so you know it’s serious.</span>It would be maybe an hour or two of me setting up a Hive server to run over all our data and then calling it good. Since our data is stored on AWS S3 I used a service called <a href="https://aws.amazon.com/athena/">Athena</a> which allows you to run Hive SQL queries on your S3 data. Not only do you get to avoid setting/ spinning up a Hive cluster, you only pay for the data searched.</p>
<p>After pointing Athena to my data and its format I ran a few tests with queries like</p>
<pre class="sql"><code>select * from intensityData limit 10;</code></pre>
<p>and got back results fast and well formed. I was set.</p>
<p>Until we tried to use the data in real life….</p>
<p>I was asked to grab all the data for a SNP so we could test a model on it. I ran the query:</p>
<pre class="sql"><code>select * from intensityData 
where snp = &#39;rs123456&#39;;</code></pre>
<p>… and I waited. Eight minutes and 4+ terabytes of data queried later I had my results. Athena charges you by data searched at the reasonable rate of $5 per TB. So this single query cost $20 and eight minutes. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">If we ever wanted to run a model over all the data we better be ready to wait roughly 38 years and pay $50 million.</span> Clearly this wasn’t going to work.</p>
</div>
<div id="this-should-be-a-walk-in-the-parquet" class="section level2">
<h2>This should be a walk in the Parquet…</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Be careful with your Parquet file sizes and organization.</span></p>
<p>My first attempt to remedy the situation was to convert all of the TSV’s to <a href="https://Parquet.apache.org">Parquet files</a>. Parquet files are good for working with larger datasets because they store data in a ‘columnar’ fashion. Meaning each column is stored in its own section of memory/disk, unlike a text file with lines containing every column. This means to look for something you only have to read the necessary column. Also, they keep a record of the range of values by column for each file so if the value you’re looking for isn’t in the column range Spark doesn’t waste it’s time scanning through the file.</p>
<p>I ran a simple <a href="https://aws.amazon.com/glue/">AWS Glue job</a> to convert our TSVs to Parquet and hooked up the new Parquet files to Athena. This took only around five hours. However, when I ran a query it took just about the same amount of time and a tiny bit less money. This is because Spark in its attempt to optimize the job just unzipped a single TSV chunk and placed it in its own Parquet chunk. Because each chunk was big enough to contain multiple people’s full records, this meant that every file had every SNP in them and thus Spark had to open all of them to extract what we wanted.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">Interestingly the default (and recomended) Parquet compression type: ‘snappy’ is not splitable. So each executor was still stuck with the task of uncompressing and loading an entire 3.5gig dataset.</span></p>
<p><img src="/using_awk_and_r_to_parse_25tb/large_parquet_chunks.png" /></p>
</div>
<div id="sorting-out-the-issue" class="section level2">
<h2>Sorting out the issue</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Sorting is hard, especially when data is distributed.</span></p>
<p>I thought that I had the problem figured out now. All I needed to do was to sort the data on the SNP column instead of the individual. This would allow a given chunk of data to only have a few SNPs in it and Parquet’s smart only-open-if-values-in-range feature could shine. Unfortunately, sorting billions of rows of data distributed across a cluster is not a trivial task.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
Me taking algorithms class in college: “Ugh, no one cares about computational complexity of all these sorting algorithms” <br><br>Me trying to sort on a column in a 20TB <a href="https://twitter.com/hashtag/Spark?src=hash&amp;ref_src=twsrc%5Etfw">#Spark</a> table: “Why is this taking so long?” <a href="https://twitter.com/hashtag/DataScience?src=hash&amp;ref_src=twsrc%5Etfw">#DataScience</a> struggles.
</p>
— Nick Strayer (<span class="citation">@NicholasStrayer</span>) <a href="https://twitter.com/NicholasStrayer/status/1105127759318319105?ref_src=twsrc%5Etfw">March 11, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">AWS doesn’t exactly want to give refunds for the cause ‘I am an absent minded graduate student.’</span></p>
<p>After attempting to run this on Amazon’s glue it ran for 2 days and then crashed.</p>
</div>
<div id="what-about-partitioning" class="section level2">
<h2>What about partitioning?</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Partitions in Spark need to be balanced.</span></p>
<p>Another idea I had was to partition the data into chromosomes. There are 23 of these (plus a few extra to account for mitochondrial DNA or unmapped regions). This would provide a way of cutting down the data into much more manageable chunks. By adding just a single line to the Spark export function in the glue script: <code>partition_by = &quot;chr&quot;</code>, the data should be put into those buckets.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote"><img src='https://cdn.prod-carehubs.net/n2/71b34990bba71dfd/uploads/2018/07/boldchromosomecellturquoise.png' alt='Chromosome graphic'/> DNA is made up of multiple chunks called Chromosomes. Img via <a href="https://kintalk.org/genetics-101/">kintalk.org</a>.</span></p>
<p>Unfortunately things didn’t work out well. This is because the chromosomes are different sizes and thus have different amounts of data within them. This meant that the tasks Spark sent out to its workers were unbalanced and ran slowly due to some of the nodes finishing early and sitting idle. The jobs <em>did</em> finish, however. But when querying for a single SNP the unbalance caused problems again. With SNPS in larger chromosomes (aka where we will actually want to get data) the cost was only improved ~10x. A lot but not enough.</p>
</div>
<div id="what-about-even-finer-partitioning" class="section level2">
<h2>What about even finer partitioning?</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Never, ever, try and make 2.5 million partitions.</span></p>
<p>I decided to get crazy with my partitioning and partitioned on each SNP. This guaranteed that each partition would be equal in size. <strong>THIS WAS A BAD IDEA.</strong> I used Glue and added the innocent line of <code>partition_by = 'snp'</code>. The job started and ran. A day later I checked and noticed nothing had been written to S3 yet so I killed the job. Turns out Glue <em>was</em> writing intermediate files to hidden S3 locations, and a lot of them, like 2 billion. This mistake ended up costing more than a thousand dollars and didn’t make my advisor happy.</p>
</div>
<div id="partitioning-sorting" class="section level2">
<h2>Partitioning + Sorting</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Sorting is still hard and so is tuning Spark.</span></p>
<p>The last attempt in the partitioning era was to partition on chromosome and then sort each partition. In theory this would have made each query quicker because the desired SNP data would only reside in the ranges of a few of the Parquet chunks within a given region. Alas, it turns out sorting even the partitioned data was a lot of work. I ended up switching to EMR for a custom cluster, using 8 powerful instances (C5.4xl) and using Sparklyr to build a more flexible workflow…</p>
<pre class="r"><code># Sparklyr snippet to partition by chr and sort w/in partition
# Join the raw data with the snp bins
raw_data
  group_by(chr) %&gt;%
  arrange(Position) %&gt;% 
  Spark_write_Parquet(
    path = DUMP_LOC,
    mode = &#39;overwrite&#39;,
    partition_by = c(&#39;chr&#39;)
  )</code></pre>
<p>…but no mater what the job never finished. I tried all the tuning tricks: bumped up the memory allocated to each executor of the queries, used high ram node types, broadcasting variables, but it would always get around half way done then executors would slowly start failing till everything eventually ground to a halt.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
Update: so it begins. <a href="https://t.co/agY4GU2ru5">pic.twitter.com/agY4GU2ru5</a>
</p>
— Nick Strayer (<span class="citation">@NicholasStrayer</span>) <a href="https://twitter.com/NicholasStrayer/status/1128703858610450434?ref_src=twsrc%5Etfw">May 15, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>
</div>
<div id="getting-more-creative" class="section level1">
<h1>Getting more creative</h1>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Sometimes bespoke data needs bespoke solutions.</span></p>
<p>Every SNP has a position value. This is an integer corresponding to how many bases along its chromosome it lies. This is a nice and natural method of organizing our data. The first thought I had was building partitions by regions of each chromosome. Aka (positions 1 - 2000, 2001 - 4000, etc). The problem is SNPs are not evenly distributed along their chromosomes, so the bins would be wildly different in size.</p>
<p><img src="/using_awk_and_r_to_parse_25tb/uneven_snps.png" /></p>
<p>The solution I came up with was to bin by position <em>rank</em>. I ran a query on our already loaded data to get the list of the unique SNPs, their positions, and their chromosomes. I then sorted within each chromosome and bundled the SNPs into bins of a given size. E.g. 1000 SNPS. This gave me a mapping from SNP -&gt; bin-in-chromosome.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">I ended up using 75 SNPs per bin, I explain why later.</span></p>
<pre class="r"><code>snp_to_bin &lt;- unique_snps %&gt;% 
  group_by(chr) %&gt;% 
  arrange(position) %&gt;% 
  mutate(
    rank = 1:n()
    bin = floor(rank/snps_per_bin)
  ) %&gt;% 
  ungroup()</code></pre>
<div id="first-attempt-with-spark" class="section level2">
<h2>First attempt with Spark</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Spark joining is fast, but partitioning is still expensive</span></p>
<p>The goal was to read this small (2.5 million row) dataframe into Spark, join it with the raw data, and then partition on the newly added <code>bin</code> column.</p>
<pre class="r"><code># Join the raw data with the snp bins
data_w_bin &lt;- raw_data %&gt;%
  left_join(sdf_broadcast(snp_to_bin), by =&#39;snp_name&#39;) %&gt;%
  group_by(chr_bin) %&gt;%
  arrange(Position) %&gt;% 
  Spark_write_Parquet(
    path = DUMP_LOC,
    mode = &#39;overwrite&#39;,
    partition_by = c(&#39;chr_bin&#39;)
  )</code></pre>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">Notice the use of <code>sdf_broadcast()</code>, this lets Spark know it should send this dataframe to all nodes. It’s helpful when the data is small and needed for all tasks. Otherwise Spark tries to be clever and waits to distribute it till it needs it which can cause bottlenecks.</span></p>
<p>Again, things didn’t work out. Like the sorting attempt, the jobs would run for a while, finish the joining task, and then as the partitioning started executors would start crashing.</p>
</div>
<div id="bringing-in-awk" class="section level2">
<h2>Bringing in AWK</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Don’t sleep on the basics. Someone probably solved your problem in the 80s.</span></p>
<p>Up to this point all my Spark failures were due to the data being shuffled around the cluster because it was starting all mixed up. Perhaps I could help it out with some preprocessing. I decided to try and split the raw text data on the chromosome column, that way I would be able to provide Spark with somewhat ‘pre-partitioned’ data.</p>
<p>I stack overflow searched how to split by column value and found <a href="https://unix.stackexchange.com/questions/114061/extract-data-from-a-file-and-place-in-different-files-based-on1-column-value">this wonderful answer.</a> Using AWK you can split a text file up by a column’s values by performing the writing in the script rather than sending results to <code>stdout</code>.</p>
<p>I wrote up a bash script to test this. I downloaded one of the gzipped tsv, then unzipped it using <code>gzip</code>, piped that to <code>awk</code>.</p>
<pre class="bash"><code>gzip -dc path/to/chunk/file.gz |
awk -F &#39;\t&#39; \
&#39;{print $1&quot;,...&quot;$30&quot;&gt;&quot;chunked/&quot;$chr&quot;_chr&quot;$15&quot;.csv&quot;}&#39;</code></pre>
<p>It worked!</p>
</div>
<div id="saturating-the-cores" class="section level2">
<h2>Saturating the cores</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> <code>gnu parallel</code> is magic and everyone should use it.</span></p>
<p>The splitting was a tad bit slow and when I ran <code>htop</code> to see the usage of the powerful (expensive) ec2 instance I was using a single core and ~200 MB of ram. If I wanted to get things done and not waste a lot of money I was going to need to figure out how to parallelize. Luckily I found the chapter on parallelizing workflows in <a href="https://www.datascienceatthecommandline.com">Data Science at the Command Line</a>, the utterly fantastic book by Jeroen Janssens. It introduced me to <code>gnu parallel</code> which is very flexible method for spinning up multiple threads in a unix pipeline.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote"><a href = 'https://www.datascienceatthecommandline.com' ><img src = 'https://www.datascienceatthecommandline.com/images/cover.png' alt = 'Data Science at the Command Line book cover.'/></a></span></p>
<p>Once I ran the splitting using the new GNU parallel workflow it was great, but I was still getting some bottle-necking caused by downloading the S3 objects to disk being a little bit slow and not fully parallelized. I did a few things to fix this.</p>
<ol style="list-style-type: decimal">
<li>Found out that you can implement the S3 download step right into the pipeline, completely skipping intermediate disk storage. This meant I could avoid writing the raw data to disk and also use smaller and thus cheaper storage on AWS.</li>
<li>Increased the number of threads that the AWS CLI uses to some large number (the default is 10) with <code>aws configure set default.s3.max_concurrent_requests 50</code>.</li>
<li>Switched to a network speed optimized ec2 instance. These are the ones with the <code>n</code> in the name. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">I found that the loss in compute power caused from using the ‘n’ instances was more than made up for by the increased download speeds.</span> I used c5n.4xl’s for most of my stuff.</li>
<li>Swapped <code>gzip</code> to <a href="https://linux.die.net/man/1/pigz"><code>pigz</code></a>, which is a parallel gzip tool that does some clever things to parallelize an inherently unparallelizable task of decompressing gziped files. (This helped the least.)</li>
</ol>
<pre class="bash"><code># Let S3 use as many threads as it wants
aws configure set default.s3.max_concurrent_requests 50

for chunk_file in $(aws s3 ls $DATA_LOC | awk &#39;{print $4}&#39; | grep &#39;chr&#39;$DESIRED_CHR&#39;.csv&#39;) ; do

        aws s3 cp s3://$batch_loc$chunk_file - |
        pigz -dc |
        parallel --block 100M --pipe  \
        &quot;awk -F &#39;\t&#39; &#39;{print \$1\&quot;,...\&quot;$30\&quot;&gt;\&quot;chunked/{#}_chr\&quot;\$15\&quot;.csv\&quot;}&#39;&quot;

       # Combine all the parallel process chunks to single files
        ls chunked/ |
        cut -d &#39;_&#39; -f 2 |
        sort -u |
        parallel &#39;cat chunked/*_{} | sort -k5 -n -S 80% -t, | aws s3 cp - &#39;$s3_dest&#39;/batch_&#39;$batch_num&#39;_{}&#39;
        
         # Clean up intermediate data
       rm chunked/*
done</code></pre>
<p>These steps combined to make things <em>very</em> fast. By virtue of increasing the speed of download and avoiding writing to disk I was now able to process a whole 5 terabyte batch in just a few hours.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
There's nothing sweeter than seeing all the cores you're paying for on AWS being used. Thanks to gnu-parallel I can unzip and split a 19gig csv just as fast as I can download it. I couldn't even get Spark to run this. <a href="https://twitter.com/hashtag/DataScience?src=hash&amp;ref_src=twsrc%5Etfw">#DataScience</a> <a href="https://twitter.com/hashtag/Linux?src=hash&amp;ref_src=twsrc%5Etfw">#Linux</a> <a href="https://t.co/Nqyba2zqEk">pic.twitter.com/Nqyba2zqEk</a>
</p>
— Nick Strayer (<span class="citation">@NicholasStrayer</span>) <a href="https://twitter.com/NicholasStrayer/status/1129416944233226240?ref_src=twsrc%5Etfw">May 17, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">This tweet should have said ‘tsv’. Alas.</span></p>
</div>
<div id="using-newly-parsed-data" class="section level2">
<h2>Using newly parsed data</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Spark likes uncompressed data and does not like combining partitions.</span></p>
<p>Now that I had the data sitting in an unzipped (see splittable) and semi-organized format on S3 I could go back to Spark. Surprise – things didn’t workout again! It was very hard to accurately tell Spark how the data was partitioned and even when I did it seemed to like to split things into way too many partitions (like 95k), which then when I used <code>coalesce</code> to reduce down to a reasonable number of partitions, ended up ruining the partitioning I had used. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">I am sure there is a way to fix this but I couldn’t find it over a couple days of looking.</span> I did end up getting things to finish on Spark, it took a while however and my split Parquet files were not super tiny (~200KB) But the data was where it needed to be.</p>
<p><img src='/using_awk_and_r_to_parse_25tb/uneven_small_partitions.png'/>
<span class="photo_caption"><em>Too small and uneven, wonderful!</em></span></p>
</div>
<div id="testing-out-local-spark-queries" class="section level2">
<h2>Testing out local Spark queries</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Spark is a lot of overhead for simple jobs.</span></p>
<p>With the data loaded up into a reasonable format I could test out the speed. I setup an R script to spin up a local Spark server and then load a Spark dataframe from a given Parquet bins location. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">I tried loading all the data but couldn’t get Sparklyr to recognize the partitioning for some reason.</span></p>
<pre class="r"><code>sc &lt;- Spark_connect(master = &quot;local&quot;)

desired_snp &lt;- &#39;rs34771739&#39;

# Start a timer
start_time &lt;- Sys.time()

# Load the desired bin into Spark
intensity_data &lt;- sc %&gt;% 
  Spark_read_Parquet(
    name = &#39;intensity_data&#39;, 
    path = get_snp_location(desired_snp),
    memory = FALSE )

# Subset bin to snp and then collect to local
test_subset &lt;- intensity_data %&gt;% 
  filter(SNP_Name == desired_snp) %&gt;% 
  collect()

print(Sys.time() - start_time)</code></pre>
<p>This took 29.415 seconds. Much better than before, but still not a great sign for mass testing of anything. In addition, I couldn’t try and speed it up by enabling caching because when I tried to cache the bin’s Spark dataframe in memory Spark always crashed, even when I gave it 50+ gigs of memory for a dataset that was at this point smaller than 15.</p>
</div>
<div id="back-to-awk" class="section level2">
<h2>Back to AWK</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Associative arrays in AWK are super powerful.</span></p>
<p>I knew I could do better. I remembered that I had read in this charming <a href="http://www.grymoire.com/Unix/Awk.html">AWK guide by Bruce Barnett</a> about a cool feature in AWK called <a href="http://www.grymoire.com/Unix/Awk.html#uh-22">&quot;associative arrays’</a>. These are essentially a key-value stores in AWK that for some reason had been given a different name and thus I never thought too much about. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">It was brought to my attention by <a href="https://ro-che.info">Roman Cheplyaka</a> that the term ‘Associative Array’ is much older than ‘key-value store’. In fact, key-value store <a href="https://books.google.com/ngrams/graph?content=key-value+store%2Cassociative+array&amp;year_start=1800&amp;year_end=2000&amp;corpus=15&amp;smoothing=3&amp;share=&amp;direct_url=t1%3B%2Cassociative%20array%3B%2Cc0#t1%3B%2Cassociative%20array%3B%2Cc0">doesn’t even show up on google ngrams</a> when you look for it, but associative array does! In addition, key-value stores are more often associated with database systems and thus a hashmap is really a more appropriate comparison here.</span> I realized that I could use these associative arrays to perform the union between my SNP -&gt; bin table and my raw data without using Spark.</p>
<p>To do this I used the <code>BEGIN</code> block in my AWK script. This is a block of code that gets run before any lines of data are fed into the main body of the script.</p>
<p><strong>join_data.awk</strong></p>
<pre><code>BEGIN {
  FS=&quot;,&quot;;
  batch_num=substr(chunk,7,1);
  chunk_id=substr(chunk,15,2);
  while(getline &lt; &quot;snp_to_bin.csv&quot;) {bin[$1] = $2}
}
{
  print $0 &gt; &quot;chunked/chr_&quot;chr&quot;_bin_&quot;bin[$1]&quot;_&quot;batch_num&quot;_&quot;chunk_id&quot;.csv&quot;
}</code></pre>
<p>The <code>while(getline...)</code> command loaded all the rows in from my bin csv and set the first column (the SNP name) as the key to the <code>bin</code> associative array and the second value (the bin) to the value. Then, in the <code>{</code> block <code>}</code> that gets run on every line of the main file, each line is sent to an output file that was had a unique name based upon its bin: <code>..._bin_&quot;bin[$1]&quot;_...</code>.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">The variables of <code>batch_num</code> and <code>chunk_id</code> corresponded to data given by the pipeline that allowed me to avoid race conditions in my writing by making sure that every thread run by <code>parallel</code> wrote to its own unique file. </span></p>
<p>Because I had all the raw data split into chromosome folders from my previous AWK experiment I could now write another bash script to work through a chromosome at a time and send back the further partitioned data to S3.</p>
<pre class="bash"><code>DESIRED_CHR=&#39;13&#39;

# Download chromosome data from s3 and split into bins
aws s3 ls $DATA_LOC |
awk &#39;{print $4}&#39; |
grep &#39;chr&#39;$DESIRED_CHR&#39;.csv&#39; |
parallel &quot;echo &#39;reading {}&#39;; aws s3 cp &quot;$DATA_LOC&quot;{} - | awk -v chr=\&quot;&quot;$DESIRED_CHR&quot;\&quot; -v chunk=\&quot;{}\&quot; -f split_on_chr_bin.awk&quot;

# Combine all the parallel process chunks to single files and upload to rds using R
ls chunked/ |
cut -d &#39;_&#39; -f 4 |
sort -u |
parallel &quot;echo &#39;zipping bin {}&#39;; cat chunked/*_bin_{}_*.csv | ./upload_as_rds.R &#39;$S3_DEST&#39;/chr_&#39;$DESIRED_CHR&#39;_bin_{}.rds&quot;
rm chunked/*</code></pre>
<p>This script has two <code>parallel</code> sections:</p>
<p>The first one reads in every file containing data for the desired chromosome and divvies them up to multiple threads that spit their files into its representative bins. In order to prevent race conditions from the multiple threads writing to the same bin file, AWK is passed the name of the file which it uses to write to unique locations, e.g. <code>chr_10_bin_52_batch_2_aa.csv</code> This results in a <em>ton</em> of tiny files located on the disk (I used 1TB EBS volumes for this).</p>
<p>The second <code>parallel</code> pipeline goes through and merges every bin’s separate files into single csv’s with <code>cat</code>, and sends them for export…</p>
</div>
<div id="piping-to-r" class="section level2">
<h2>Piping to R?</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> You can access <code>stdin</code> and <code>stdout</code> from inside an R script and thus use it in a pipeline.</span></p>
<p>You may have noticed this part of the bash script above: <code>...cat chunked/*_bin_{}_*.csv | ./upload_as_rds.R...</code>. This line pipes all the concatenated files for a bin into the following R script… <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">The <code>{}</code> in there is a special <code>parallel</code> technique that pastes whatever data it is sending to the given thread right into the command it’s sending. Other option are <code>{#}</code> which gives the unique thread ID and <code>{%}</code> which is the job slot number (repeates but never at the same time). For all of the option checkout <a href="https://www.gnu.org/software/parallel/parallel_tutorial.html#Replacement-strings">the docs.</a></span></p>
<pre class="r"><code>#!/usr/bin/env Rscript
library(readr)
library(aws.s3)

# Read first command line argument
data_destination &lt;- commandArgs(trailingOnly = TRUE)[1]

data_cols &lt;- list(SNP_Name = &#39;c&#39;, ...)

s3saveRDS(
  read_csv(
        file(&quot;stdin&quot;), 
        col_names = names(data_cols),
        col_types = data_cols 
    ),
  object = data_destination
)</code></pre>
<p>By passing <code>readr::read_csv</code> the variable <code>file(&quot;stdin&quot;)</code> it loads the data piped to the R script into a dataframe, which then gets written as an <code>.rds</code> file directly to s3 using <code>aws.s3</code>.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">Rds is kind-of like a junior version of Parquet without the niceties of columnar storage.</span></p>
<p>After this bash script had finished I have a bunch of <code>.rds</code> files sitting in S3 benefiting with the benefits of efficient compression and built-in types.</p>
<p>Even with notoriously slow R in the workflow, this was super fast. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">Unsurprisingly the parts of R for reading and writing data are rather optimized.</span> After testing on a single average size chromosome the job finished in about two hours using a C5n.4xl instance.</p>
</div>
<div id="limits-of-s3" class="section level2">
<h2>Limits of S3</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> S3 can handle a <em>lot</em> of files due to smart path implementation.</span></p>
<p>I was worried about how S3 would handle having a ton of files dumped onto it. I could make the file names make sense, but how would S3 handle searching for one?</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote"><img src='/using_awk_and_r_to_parse_25tb/s3_keys_explained.png'/> Folders in S3 are just a cosmetic thing and S3 doesn’t actually care about the <code>/</code> character.<a href='https://aws.amazon.com/s3/faqs/'>From the S3 FAQs page</a></span></p>
<p>It turns out S3 treats the path to a given file as a simple key in what can be thought of as a hash table, or a document-based database. Think of a “bucket” as a table and every file is an entry.</p>
<p>Because speed and efficiency are important to S3 making money for Amazon, it’s no surprise that this key-is-a-file-path system is super optimized. Still, I tried to strike a balance. I wanted to not need to do a ton of <code>get</code> requests and I wanted the queries to be fast. I found that making around 20k bin files worked best. <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">I am sure further optimizations could speed things up (such as making a special bucket just for the data and thus reducing the size of the lookup table.) But I ran out of time and money to do more experiments.</span></p>
</div>
<div id="what-about-cross-compatibility" class="section level2">
<h2>What about cross-compatibility?</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Premature optimization of your storage method is the root of all time wasted.</span></p>
<p>A very reasonable thing to ask at this point is “why would you use a proprietary file format for this?” The reason came down to speed of loading (using gzipped csvs took about 7 times longer to load) and compatibility with our workflows.<label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">Once R can easily load Parquet (or Arrow) files without the overhead of Spark I may reconsider.</span> Everyone else in my lab exclusively uses R and if I end up needing to convert the data to another format I still have the original raw text data and can just run the pipeline again.</p>
</div>
<div id="divvying-out-the-work" class="section level2">
<h2>Divvying out the work</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Don’t try to hand optimize jobs, let the computer do it.</span></p>
<p>Now that I had the workflow for a single chromosome working, I needed to process every chromosome’s data. I wanted to spin up multiple ec2 instances to convert all my data but I also didn’t want to have super unbalanced job loads (just like how Spark suffered from the unbalanced partitions). <label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">I also didn’t want to spin up a single instance for each chromosome, since there is a limit by default of 10 instances at a time for AWS accounts.</span></p>
<p>My solution was to write a brute force job optimization script using R….</p>
<p>First I queried S3 to figure out how large each chromosome was in terms of storage.</p>
<pre class="r"><code>library(aws.s3)
library(tidyverse)

chr_sizes &lt;- get_bucket_df(
  bucket = &#39;...&#39;, prefix = &#39;...&#39;, max = Inf
) %&gt;% 
  mutate(Size = as.numeric(Size)) %&gt;% 
  filter(Size != 0) %&gt;% 
  mutate(
    # Extract chromosome from the file name 
    chr = str_extract(Key, &#39;chr.{1,4}\\.csv&#39;) %&gt;%
             str_remove_all(&#39;chr|\\.csv&#39;)
  ) %&gt;% 
  group_by(chr) %&gt;% 
  summarise(total_size = sum(Size)/1e+9) # Divide to get value in GB</code></pre>
<pre><code># A tibble: 27 x 2
   chr   total_size
   &lt;chr&gt;      &lt;dbl&gt;
 1 0           163.
 2 1           967.
 3 10          541.
 4 11          611.
 5 12          542.
 6 13          364.
 7 14          375.
 8 15          372.
 9 16          434.
10 17          443.
# … with 17 more rows</code></pre>
<p>Then I wrote a function that would take this total size info, shuffle the order, and split into <code>num_jobs</code> groups and report how variable the sizes of each job’s data was.</p>
<pre class="r"><code>num_jobs &lt;- 7
# How big would each job be if perfectly split?
job_size &lt;- sum(chr_sizes$total_size)/7

shuffle_job &lt;- function(i){
  chr_sizes %&gt;%
    sample_frac() %&gt;% 
    mutate(
      cum_size = cumsum(total_size),
      job_num = ceiling(cum_size/job_size)
    ) %&gt;% 
    group_by(job_num) %&gt;% 
    summarise(
      job_chrs = paste(chr, collapse = &#39;,&#39;),
      total_job_size = sum(total_size)
    ) %&gt;% 
    mutate(sd = sd(total_job_size)) %&gt;% 
    nest(-sd)
}

shuffle_job(1)</code></pre>
<pre><code># A tibble: 1 x 2
     sd data            
  &lt;dbl&gt; &lt;list&gt;          
1  153. &lt;tibble [7 × 3]&gt;</code></pre>
<p>Once this was setup I ran a thousand shuffles using purrr and picked the best one.</p>
<pre class="r"><code>1:1000 %&gt;% 
  map_df(shuffle_job) %&gt;% 
  filter(sd == min(sd)) %&gt;% 
  pull(data) %&gt;% 
  pluck(1)</code></pre>
<p>This gave me a set of jobs that were all very close in size. All I had do do then was wrap my previous bash script in a big for loop…
<label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">It took me ~10 mins to write this job optimization which was way less time than the inballance caused by my manual job creation would have added to the processing so I think I didn’t fall for premature optimization here.</span></p>
<pre class="bash"><code>for DESIRED_CHR in &quot;16&quot; &quot;9&quot; &quot;7&quot; &quot;21&quot; &quot;MT&quot;
do
# Code for processing a single chromosome
fi</code></pre>
<p>add a shutdown command at the end….</p>
<pre class="bash"><code>sudo shutdown -h now</code></pre>
<p>… and I was off the the races. I used the AWS CLI to spin up a bunch of instances, passing them their job’s bash script via the <code>user_data</code> option. They ran and then shutdown automatically so I didn’t pay for extra compute.</p>
<pre class="bash"><code>aws ec2 run-instances ...\
--tag-specifications &quot;ResourceType=instance,Tags=[{Key=Name,Value=&lt;&lt;job_name&gt;&gt;}]&quot; \
--user-data file://&lt;&lt;job_script_loc&gt;&gt;</code></pre>
</div>
</div>
<div id="packing-it-up" class="section level1">
<h1>Packing it up!</h1>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> Keep API simple for your end users and flexible for you.</span></p>
<p>Finally, the data was where and how I needed it. The last step was to simplify the process for using the data as much as possible for my lab members. I wanted to provide a simple API for querying. If in the future I did decide to switch from using <code>.rds</code> to Parquet files I wanted to be able to make that my issue and not my lab mate’s. The way I decided to to this was an internal R package.</p>
<p>I built and documented a very simple package that contains just a few functions for accessing the data, centered around the function <code>get_snp</code>. Additionally, I built a <a href="https://pkgdown.r-lib.org">pkgdown site</a> so lab members could easily see examples/docs.</p>
<p><img src="/using_awk_and_r_to_parse_25tb/pkg_down.png" /></p>
<div id="intelligent-caching." class="section level2">
<h2>Intelligent caching.</h2>
<p><span class="lesson_learned"><strong>Lesson Learned:</strong> If your data is setup well, caching will be easy!</span></p>
<p>Since one of the main workflows for these data was running the same model/ analysis across a bunch of SNPs at a time, I decided that I should use the binning to my advantage. When pulling the data down for a SNP, the entire bin’s data is kept and attached to the returned object. This means if a new query is run the old queries result’s can (potentially) be used to speed it up.</p>
<pre class="r"><code># Part of get_snp()
...
  # Test if our current snp data has the desired snp.
  already_have_snp &lt;- desired_snp %in% prev_snp_results$snps_in_bin

  if(!already_have_snp){
    # Grab info on the bin of the desired snp
    snp_results &lt;- get_snp_bin(desired_snp)

    # Download the snp&#39;s bin data
    snp_results$bin_data &lt;- aws.s3::s3readRDS(object = snp_results$data_loc)
  } else {
    # The previous snp data contained the right bin so just use it
    snp_results &lt;- prev_snp_results
  }
...</code></pre>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">While building the package I ran a lot of benchmarks to compare the speed between different methods. I recomend it because sometimes the results went against my intuition. For instance, <code>dplyr::filter</code> was much faster than using indexing based filtering for grabbing rows, but getting a single column from a filtered dataframe was much faster using indexing syntax.</span></p>
<p>Notice that the <code>prev_snp_results</code> object contains the key <code>snps_in_bin</code>. This is an array of all unique SNPs in the bin, allowing fast checking for if we already have the data from a previous query. It also makes it easy for the user to loop through all the SNPs in a bin using code like:</p>
<pre class="r"><code># Get bin-mates
snps_in_bin &lt;- my_snp_results$snps_in_bin

for(current_snp in snps_in_bin){
  my_snp_results &lt;- get_snp(current_snp, my_snp_results)
  # Do something with results 
}</code></pre>
</div>
</div>
<div id="end-results" class="section level1">
<h1>End results</h1>
<p>We are now able to (and have started in earnest) run models and scenarios we were incapable of before. The best part is the other members of my lab don’t have to think about the complexities that went into it. They just have a function that works.</p>
<p><label for="tufte-mn-" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-" class="margin-toggle"><span class="marginnote">Even though the package abstracts away the details, I tried to make the format of the data simple enough that if I were to dissapear tomorrow someone could figure it out.</span></p>
<p>The speed is much improved. A typical use-case is to scan a functionally significant region of the genome (such as a gene). Before we couldn’t do this (because it cost too much) but now, because of the bin structure and caching, it takes on average less than a tenth of a second per SNP queried and the data usage is not even high enough to round up to a penny on our S3 costs.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
Recently I got put in change of wrangling 25+ TB of raw genotyping data for my lab. When I started, using Spark took 8 min &amp; cost $20 to query a SNP. After using AWK + <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> to process, it now takes less than a 10th of a second and costs $0.00001. My personal <a href="https://twitter.com/hashtag/BigData?src=hash&amp;ref_src=twsrc%5Etfw">#BigData</a> win. <a href="https://t.co/ANOXVGrmkk">pic.twitter.com/ANOXVGrmkk</a>
</p>
— Nick Strayer (<span class="citation">@NicholasStrayer</span>) <a href="https://twitter.com/NicholasStrayer/status/1134151057385369600?ref_src=twsrc%5Etfw">May 30, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<div id="take-away" class="section level2">
<h2>Take Away</h2>
<p>This post post isn’t meant to be a how-to guide. The final solution is bespoke and almost assuredly not the optimal one. For risk of sounding unbearably cheesy this was about the journey. I want others to realize that these solutions don’t pop fully formed into peoples head’s but they are a product of trial and error.</p>
<p>In addition, if you are in the position of hiring someone as a data scientist please consider the fact that getting good at these tools requires experience, and experience requires money. I am lucky that I have grant funding to pay for this but many who assuredly could do a better job than me will never get the chance because they don’t have the funds to even try.</p>
<p>“Big Data” tools are generalists. If you have the time you will almost assuredly be able to write up a faster solution to your problem using smart data cleaning, storage, and retrieval techniques. Ultimately it comes down to a cost-benefit analysis.</p>
<div id="all-lessons-learned" class="section level3">
<h3>All lessons learned:</h3>
<p>In case you wanted everything in a neat list format:</p>
<ul>
<li><span class="lesson_learned">There’s no cheap way to parse 25tb of data at once.</span></li>
<li><span class="lesson_learned">Be careful with your Parquet file sizes and organization.</span></li>
<li><span class="lesson_learned">Partitions in Spark need to be balanced.</span></li>
<li><span class="lesson_learned">Never, ever, try and make 2.5 million partitions.</span></li>
<li><span class="lesson_learned">Sorting is still hard and so is tuning Spark.</span></li>
<li><span class="lesson_learned">Sometimes bespoke data needs bespoke solutions.</span></li>
<li><span class="lesson_learned">Spark joining is fast, but partitioning is still expensive</span></li>
<li><span class="lesson_learned">Don’t sleep on the basics. Someone probably solved your problem in the 80s.</span></li>
<li><span class="lesson_learned"><code>gnu parallel</code> is magic and everyone should use it.</span></li>
<li><span class="lesson_learned">Spark likes uncompressed data and does not like combining partitions.</span></li>
<li><span class="lesson_learned">Spark is a lot of overhead for simple jobs.</span></li>
<li><span class="lesson_learned">Associative arrays in AWK are super powerful.</span></li>
<li><span class="lesson_learned">You can access <code>stdin</code> and <code>stdout</code> from inside an R script and thus use it in a pipeline.</span></li>
<li><span class="lesson_learned">S3 can handle a <em>lot</em> of files due to smart path implementation.</span></li>
<li><span class="lesson_learned">Premature optimization of your storage method is the root of all time wasted.</span></li>
<li><span class="lesson_learned">Don’t try to hand optimize jobs, let the computer do it.</span></li>
<li><span class="lesson_learned">Keep API simple for your end users and flexible for you.</span></li>
<li><span class="lesson_learned">If your data is setup well, caching will be easy!</span></li>
</ul>
</div>
</div>
</div>
